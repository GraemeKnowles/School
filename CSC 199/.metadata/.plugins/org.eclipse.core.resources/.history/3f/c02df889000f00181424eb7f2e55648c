package recursiveDescent;

import java.util.ArrayList;
import java.util.List;

//function ::= validName{ term}
class Function extends Token {

	public static Function parse(InputScanner input) {
		Function f = new Function();
		f.name = ValidName.parse(input);
		if (f.name.toString().compareTo("") == 0) {
			throw new IllegalArgumentException("Invalid Function Name");
		}

		f.parseTerms(input);
		return f;
	}
	
	private ValidName name;
	private List<Term> terms = new ArrayList<Term>();
	
	protected Function() {}

	protected void parseTerms(InputScanner input) {
		do {
			char nextChar = input.peekNexy();
			if (nextChar == ' ') {
				Term newTerm = Term.parse(input);
				if (newTerm == null) {
					return;
				} else {
					this.addTerm(newTerm);
				}
			} else {
				input.prevChar();
				return;
			}
		} while (true);
	}
	
	protected List<Term> getTerms() {
		return terms;
	}

	protected void addTerm(Term t) {
		terms.add(t);
	}

	protected void setName(ValidName name) {
		this.name = name;
	}
	
	public String getName() {
		return name.toString();
	}

	@Override
	public String toInfix() {
		
		final String fungpUtil = "fungp.util/";
		final String math = "Math/";
		
		// Clean name
		String name = getName();
		if (name.contains(fungpUtil)) {
			name = name.substring(fungpUtil.length());
		} else if(name.contains(math)) {
			name = name.substring(math.length());
		}
		
		// Handle special cases
		switch(name) {
		case "sdiv":
			String denom = terms.get(1).toInfix();
			return "(" + terms.get(0).toInfix() + "/" + (Float.parseFloat(denom) == 0 ? "1" : denom) + ")";
			//break;
		case "inc":
			return "(" + terms.get(0).toInfix() + "+1" + ")";
			//break;
		case "dec":
			return "(" + terms.get(0).toInfix() + "-1" + ")";
			//break;
		case "expt":
			return "(" + terms.get(0).toInfix() + "^" + terms.get(1).toInfix()+ ")";
			//break;
		case "rem":
			name = "mod";
			//fallthrough intended
		default:
			String infix = name + "(";
			for (int i = 0, lastComma = terms.size() - 1; i < terms.size(); ++i) {
				infix += terms.get(i).toInfix();
				if (i < lastComma) {
					infix += ",";
				}
			}

			infix += ")";
			return infix;
			//break;
		}		
	}
}
